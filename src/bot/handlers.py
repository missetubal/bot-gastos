# src/bot/handlers.py
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import ContextTypes, ConversationHandler
import datetime
from typing import Union, Dict, Any, List

from src.core.ai import extract_transaction_info, extract_correction_from_llama # <--- Certifique-se que extract_correction_from_llama est√° importado
from src.core import db
from src.utils.text_utils import to_camel_case
from src.core import charts

# --- Estados da Conversa ---
HANDLE_INITIAL_MESSAGE = 0
ASKING_CATEGORY_CLARIFICATION = 1
ASKING_NEW_CATEGORY_NAME = 2
ASKING_PAYMENT_METHOD = 3
ASKING_CONFIRMATION = 4
ASKING_CORRECTION = 5

# --- Fun√ß√µes Auxiliares ---
async def _send_confirmation_message(update: Update, context: ContextTypes.DEFAULT_TYPE, transaction_info: Dict[str, Any]) -> None:
    """Envia a mensagem de confirma√ß√£o da transa√ß√£o ao usu√°rio com emojis e formata√ß√£o."""
    supabase_client = context.bot_data['supabase_client']
    valor_fmt = f"R${transaction_info['valor']:.2f}"
    data_fmt = transaction_info['data']
    
    categoria_nome_real = transaction_info.get('categoria_nome_db') or transaction_info.get('categoria')
    if transaction_info.get('categoria_id') and not transaction_info.get('categoria_nome_db'):
        cat_info = next((c for c in db.get_categorias(supabase_client) if c['id'] == transaction_info['categoria_id']), None)
        if cat_info:
            categoria_nome_real = cat_info['nome']
    
    forma_pagamento_nome_real = transaction_info.get('forma_pagamento_nome_real') or transaction_info.get('forma_pagamento_text')
    if transaction_info.get('forma_pagamento_id') and not transaction_info.get('forma_pagamento_nome_real'):
        fp_info = next((f for f in db.get_formas_pagamento(supabase_client) if f['id'] == transaction_info['forma_pagamento_id']), None)
        if fp_info:
            forma_pagamento_nome_real = fp_info['nome']

    descricao_gasto_fmt = f"({transaction_info.get('descricao_gasto', 'sem detalhes')})" if transaction_info.get('descricao_gasto') else ""

    emoji = ""
    # Emojis para categorias
    if categoria_nome_real and categoria_nome_real.lower() == 'alimentacao':
        emoji = "üçî"
    elif categoria_nome_real and categoria_nome_real.lower() == 'transporte':
        emoji = "üöå"
    elif categoria_nome_real and categoria_nome_real.lower() == 'moradia':
        emoji = "üè†"
    elif categoria_nome_real and categoria_nome_real.lower() == 'lazer':
        emoji = "üéâ"
    elif categoria_nome_real and categoria_nome_real.lower() == 'saude':
        emoji = "üíä"
    elif categoria_nome_real and categoria_nome_real.lower() == 'educacao':
        emoji = "üìö"
    elif categoria_nome_real and categoria_nome_real.lower() == 'compras':
        emoji = "üõçÔ∏è"
    elif categoria_nome_real and categoria_nome_real.lower() == 'outros':
        emoji = "ü§∑‚Äç‚ôÄÔ∏è"
    elif categoria_nome_real and categoria_nome_real.lower() == 'desconhecida':
        emoji = "‚ùì"
    else:
        emoji = "üí∏" # Emoji gen√©rico para outros gastos

    message_text = ""
    if transaction_info['transaction_type'] == 'gasto':
        message_text = (
            f"Confirma o *gasto*? {emoji}\n"
            f"üí∞ Valor: *{valor_fmt}* {descricao_gasto_fmt}\n"
            f"üè∑Ô∏è Categoria: *{categoria_nome_real}*\n"
            f"üìÖ Data: *{data_fmt}*\n"
            f"üí≥ Pagamento: *{forma_pagamento_nome_real or 'N√£o Informado'}*"
        )
    elif transaction_info['transaction_type'] == 'ganho':
        emoji = "üí∞"
        message_text = (
            f"Confirma o *ganho*? {emoji}\n"
            f"üí∞ Valor: *{valor_fmt}*\n"
            f"üìù Descri√ß√£o: *{transaction_info.get('descricao')}*\n"
            f"üìÖ Data: *{data_fmt}*"
        )
    
    keyboard = [["Sim ‚úÖ", "N√£o ‚ùå"]]
    reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
    await update.message.reply_text(f"{message_text}\n\n*Tudo certo?* ü§î", reply_markup=reply_markup, parse_mode='Markdown')


async def _register_gasto(update: Update, context: ContextTypes.DEFAULT_TYPE, transaction_info: Dict[str, Any]) -> None:
    """Registra um gasto no banco de dados e envia a confirma√ß√£o."""
    supabase_client = context.bot_data['supabase_client']
    valor = transaction_info['valor']
    categoria_id = transaction_info['categoria_id']
    data = transaction_info['data']
    forma_pagamento_id = transaction_info.get('forma_pagamento_id')
    descricao_gasto = transaction_info.get('descricao_gasto')
    categoria_nome_db = transaction_info.get('categoria_nome_db')
    final_payment_method_name = transaction_info.get('forma_pagamento_nome_real') or transaction_info.get('forma_pagamento_text')

    if db.add_gasto(supabase_client, valor, categoria_id, data, forma_pagamento_id, descricao_gasto):
        await update.message.reply_text(
            f"‚úÖ Gasto de R${valor:.2f} ({descricao_gasto}) em '{categoria_nome_db}' via '{final_payment_method_name}' registrado com sucesso! üéâ",
            reply_markup=ReplyKeyboardRemove()
        )
        original_category_text = transaction_info.get('original_category_text')
        if original_category_text and original_category_text.lower() != categoria_nome_db.lower():
            current_aliases = set()
            for cat in db.get_categorias(supabase_client):
                if cat['id'] == categoria_id:
                    if cat['aliases'] and isinstance(cat['aliases'], list):
                        current_aliases.update(cat['aliases'])
                    break
            if original_category_text.lower() not in [a.lower() for a in current_aliases]:
                current_aliases.add(original_category_text)
                db.update_categoria_aliases(supabase_client, categoria_id, list(current_aliases))
                await update.message.reply_text(f"‚ú® '{original_category_text}' foi adicionado como um atalho para '{categoria_nome_db}'. O bot aprender√° com isso! üß†", reply_markup=ReplyKeyboardRemove())
    else:
        await update.message.reply_text("‚ùå Ocorreu um erro ao registrar seu gasto. Tente novamente mais tarde. üòü", reply_markup=ReplyKeyboardRemove())

async def _register_ganho(update: Update, context: ContextTypes.DEFAULT_TYPE, transaction_info: Dict[str, Any]) -> None:
    """Registra um ganho no banco de dados e envia a confirma√ß√£o."""
    supabase_client = context.bot_data['supabase_client']
    valor = transaction_info['valor']
    data = transaction_info['data']
    descricao = transaction_info['descricao']

    if db.add_ganho(supabase_client, valor, descricao, data):
        await update.message.reply_text(f"‚úÖ Ganho de R${valor:.2f} de '{descricao}' registrado com sucesso! ü•≥", reply_markup=ReplyKeyboardRemove())
    else:
        await update.message.reply_text("‚ùå Ocorreu um erro ao registrar seu ganho. Tente novamente mais tarde. üòü", reply_markup=ReplyKeyboardRemove())


# --- Handlers Principais ---
async def handle_initial_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Union[int, None]:
    supabase_client = context.bot_data['supabase_client']
    user_message = update.message.text
    chat_id = update.message.chat_id

    print(f"Mensagem recebida de {chat_id}: {user_message}")

    if not user_message:
        return ConversationHandler.END # N√£o faz nada se a mensagem for vazia

    parsed_info: Union[Dict[str, Any], None] = extract_transaction_info(user_message, supabase_client)

    if not parsed_info:
        await update.message.reply_text(
            "üòï Desculpe, n√£o consegui entender sua mensagem. "
            "Por favor, tente descrever claramente sua inten√ß√£o (gasto, ganho, adicionar categoria, mostrar balan√ßo/gr√°fico). "
            "Se precisar de ajuda, use /help. üí°"
        )
        return ConversationHandler.END

    intencao = parsed_info.get('intencao')

    # --- L√≥gica para Adicionar Categoria ---
    if intencao == 'adicionar_categoria':
        categoria_nome_input = parsed_info.get('categoria_nome')
        limite_mensal = parsed_info.get('limite_mensal')

        if not categoria_nome_input:
            await update.message.reply_text("ü§î N√£o consegui identificar o nome da categoria que voc√™ quer adicionar.")
            return ConversationHandler.END

        if db.add_categoria(supabase_client, categoria_nome_input, limite_mensal=limite_mensal):
            nome_exibicao = to_camel_case(categoria_nome_input)
            limite_msg = f" com limite de R${limite_mensal:.2f}" if limite_mensal is not None and limite_mensal > 0 else ""
            await update.message.reply_text(f"üéâ Categoria '{nome_exibicao}' adicionada{limite_msg} com sucesso!")
        else:
            nome_exibicao = to_camel_case(categoria_nome_input)
            await update.message.reply_text(f"‚ö†Ô∏è Erro ao adicionar categoria '{nome_exibicao}'. Ela j√° existe ou ocorreu um problema. Tente outro nome! üßê")
        return ConversationHandler.END # Fim da conversa

    # --- L√≥gica para Registrar Gasto ou Ganho (iniciar fluxo de confirma√ß√£o) ---
    elif intencao == 'gasto' or intencao == 'ganho':
        context.user_data['pending_transaction'] = parsed_info
        
        # Para gastos, prepare mais dados para o user_data
        if intencao == 'gasto':
            valor = float(parsed_info['valor'])
            data = parsed_info.get('data', str(datetime.date.today()))
            categoria_texto_llama = parsed_info.get('categoria', 'Outros') or 'Outros' 
            forma_pagamento_text = parsed_info.get('forma_pagamento')
            descricao_gasto = parsed_info.get('descricao_gasto', user_message)

            context.user_data['pending_transaction'].update({
                'valor': valor,
                'data': data,
                'original_category_text': categoria_texto_llama,
                'forma_pagamento_text': forma_pagamento_text,
                'descricao_gasto': descricao_gasto,
                'transaction_type': 'gasto'
            })
            
            categoria_id = db.get_categoria_id_by_text(supabase_client, categoria_texto_llama)
            if categoria_id:
                context.user_data['pending_transaction']['categoria_id'] = categoria_id
                context.user_data['pending_transaction']['categoria_nome_db'] = next((cat['nome'] for cat in db.get_categorias(supabase_client) if cat['id'] == categoria_id), categoria_texto_llama)
            else:
                similar_categories = db.find_similar_categories(supabase_client, categoria_texto_llama)
                context.user_data['pending_transaction']['suggestions'] = similar_categories
                
                keyboard_options = [[cat['nome']] for cat in similar_categories]
                keyboard_options.append(["Criar nova categoria ‚ûï", "N√£o se aplica / Outra ü§∑‚Äç‚ôÄÔ∏è"])
                reply_markup = ReplyKeyboardMarkup(keyboard_options, one_time_keyboard=True, resize_keyboard=True)
                await update.message.reply_text(
                    f"üßê N√£o encontrei uma categoria exata para '{categoria_texto_llama}'. "
                    f"Seria uma destas? Se sim, clique ou digite o nome. "
                    f"Ou voc√™ pode 'Criar nova categoria ‚ûï' ou 'N√£o se aplica / Outra ü§∑‚Äç‚ôÄÔ∏è'.",
                    reply_markup=reply_markup
                )
                return ASKING_CATEGORY_CLARIFICATION
            
            forma_pagamento_id = None
            forma_pagamento_nome_real = None
            if forma_pagamento_text:
                forma_pagamento_normalizada = to_camel_case(forma_pagamento_text)
                formas_pagamento_db_info = db.get_formas_pagamento(supabase_client)
                for fp in formas_pagamento_db_info:
                    if fp['nome'] == forma_pagamento_normalizada:
                        forma_pagamento_id = fp['id']
                        forma_pagamento_nome_real = fp['nome']
                        break
            
            if not forma_pagamento_id:
                formas_pagamento_disponiveis = db.get_formas_pagamento(supabase_client)
                keyboard_options = [[fp['nome']] for fp in formas_pagamento_disponiveis]
                keyboard_options.append(["Outro / N√£o sei ‚ùì"])
                reply_markup = ReplyKeyboardMarkup(keyboard_options, one_time_keyboard=True, resize_keyboard=True)
                await update.message.reply_text(
                    "üí≥ Qual foi a forma de pagamento?",
                    reply_markup=reply_markup
                )
                return ASKING_PAYMENT_METHOD
            
            context.user_data['pending_transaction']['forma_pagamento_id'] = forma_pagamento_id
            context.user_data['pending_transaction']['forma_pagamento_nome_real'] = forma_pagamento_nome_real
            
        elif intencao == 'ganho':
            valor = float(parsed_info['valor'])
            data = parsed_info.get('data', str(datetime.date.today()))
            descricao = parsed_info.get('descricao', 'Diversos')
            context.user_data['pending_transaction'].update({
                'valor': valor,
                'data': data,
                'descricao': descricao,
                'transaction_type': 'ganho'
            })
            
        await _send_confirmation_message(update, context, context.user_data['pending_transaction'])
        return ASKING_CONFIRMATION

    elif intencao in ['mostrar_balanco', 'mostrar_grafico_gastos_categoria', 'mostrar_grafico_gastos_por_pagamento', 'mostrar_grafico_mensal_combinado']:
        data_inicio = parsed_info.get('data_inicio')
        data_fim = parsed_info.get('data_fim')
        
        forma_pagamento_id = None
        categoria_id = None
        
        if intencao == 'mostrar_grafico_gastos_categoria':
            forma_pagamento_text = parsed_info.get('forma_pagamento')
            if forma_pagamento_text:
                forma_pagamento_normalizada = to_camel_case(forma_pagamento_text)
                forma_pagamento_id = db.get_forma_pagamento_id_by_name(supabase_client, forma_pagamento_normalizada)
                if not forma_pagamento_id:
                    await update.message.reply_text(f"‚ö†Ô∏è Forma de pagamento '{forma_pagamento_text}' n√£o reconhecida. Gerando gr√°fico sem este filtro. üìä")
            chart_buffer = charts.generate_category_spending_chart(supabase_client, forma_pagamento_id=forma_pagamento_id, data_inicio=data_inicio, data_fim=data_fim)
            title = "Gastos por Categoria"
        
        elif intencao == 'mostrar_grafico_gastos_por_pagamento':
            categoria_texto_llama = parsed_info.get('categoria')
            if categoria_texto_llama:
                categoria_id = db.get_categoria_id_by_text(supabase_client, categoria_texto_llama)
                if not categoria_id:
                    await update.message.reply_text(f"‚ö†Ô∏è Categoria '{categoria_texto_llama}' n√£o reconhecida. Gerando gr√°fico sem este filtro. üìä")
            chart_buffer = charts.generate_payment_method_spending_chart(supabase_client, categoria_id=categoria_id, data_inicio=data_inicio, data_fim=data_fim)
            title = "Gastos por Forma de Pagamento"
        
        elif intencao == 'mostrar_balanco':
            chart_buffer = charts.generate_balance_chart(supabase_client, data_inicio=data_inicio, data_fim=data_fim)
            title = "Balan√ßo Mensal"
        
        elif intencao == 'mostrar_grafico_mensal_combinado':
            chart_buffer = charts.generate_monthly_category_payment_chart(supabase_client, data_inicio=data_inicio, data_fim=data_fim)
            title = "Gastos Mensais Combinados"

        else:
            await update.message.reply_text("ü§î N√£o consegui identificar o tipo de gr√°fico. Use `/help` para ver as op√ß√µes. üí°")
            return ConversationHandler.END

        if chart_buffer:
            await update.message.reply_photo(photo=chart_buffer, caption=f"üìä Aqui est√° seu gr√°fico de {title}:")
        else:
            await update.message.reply_text(f"üìâ Ainda n√£o tenho dados suficientes para gerar este gr√°fico. Registre mais transa√ß√µes primeiro! üìù")
        
        return ConversationHandler.END
    elif intencao == 'listar_gastos_detalhados':
            categoria_texto_llama = parsed_info.get('categoria')
            data_inicio = parsed_info.get('data_inicio')
            data_fim = parsed_info.get('data_fim')

            gastos_filtrados = []
            period_title = ""

            # L√≥gica para filtrar por categoria, se fornecida
            categoria_id = None
            if categoria_texto_llama:
                categoria_id = db.get_categoria_id_by_text(supabase_client, categoria_texto_llama)
                if not categoria_id:
                    await update.message.reply_text(f"‚ö†Ô∏è Categoria '{categoria_texto_llama}' n√£o reconhecida. Listando todos os gastos no per√≠odo.")
            
            # L√≥gica para filtrar por data, se fornecida
            gastos_data_raw = db.get_gastos(supabase_client) # Pega todos os gastos
            gastos_filtrados = charts.filter_gastos_data(gastos_data_raw, categoria_id=categoria_id, data_inicio=data_inicio, data_fim=data_fim)
            
            # Constr√≥i o t√≠tulo do per√≠odo/categoria para a mensagem
            if data_inicio and data_fim:
                start_date_obj = datetime.datetime.strptime(data_inicio, '%Y-%m-%d')
                end_date_obj = datetime.datetime.strptime(data_fim, '%Y-%m-%d')
                if start_date_obj.day == 1 and end_date_obj.day == (end_date_obj + datetime.timedelta(days=1)).day - 1 and start_date_obj.month == end_date_obj.month and start_date_obj.year == end_date_obj.year:
                    period_title = f" do m√™s de {start_date_obj.strftime('%B/%Y').capitalize()}"
                else:
                    period_title = f" de {start_date_obj.strftime('%d/%m/%Y')} a {end_date_obj.strftime('%d/%m/%Y')}"
            
            if categoria_id and not period_title: # Se filtrou s√≥ por categoria
                 categoria_nome_real = next((cat['nome'] for cat in db.get_categorias(supabase_client) if cat['id'] == categoria_id), categoria_texto_llama)
                 period_title = f" da categoria {categoria_nome_real}"
            elif not categoria_id and not period_title: # Se n√£o teve filtro
                 period_title = " (Todos os Gastos)"


            if gastos_filtrados:
                message = f"**Detalhes dos Gastos{period_title}:**\n\n"
                total_sum = 0.0
                gastos_filtrados_sorted = sorted(gastos_filtrados, key=lambda x: x['data'], reverse=True)
                
                for gasto in gastos_filtrados_sorted:
                    valor_fmt = f"R${gasto['valor']:.2f}"
                    data_fmt = gasto['data'].strftime('%Y-%m-%d') # Formata para string
                    categoria_nome = gasto.get('categoria_nome', 'Desconhecida')
                    forma_pagamento_nome = gasto.get('forma_pagamento_nome', 'N√£o Informado')
                    descricao = gasto.get('descricao', 'Sem descri√ß√£o')
                    
                    message += (
                        f"‚Ä¢ {valor_fmt} {descricao} ({categoria_nome} - {forma_pagamento_nome}) em {data_fmt}\n"
                    )
                    total_sum += gasto['valor']
                
                message += f"\n**Total: R${total_sum:.2f}**"
                await update.message.reply_text(message, parse_mode='Markdown')
            else:
                await update.message.reply_text(f"Nenhum gasto encontrado{period_title} com os crit√©rios fornecidos. ü§∑‚Äç‚ôÄÔ∏è")
            return ConversationHandler.END
    else:
        await update.message.reply_text(
            "ü§î N√£o consegui entender sua inten√ß√£o. Por favor, tente descrever claramente "
            "um gasto, um ganho, a adi√ß√£o de uma categoria ou o pedido de um gr√°fico. üí°"
        )
        return ConversationHandler.END


async def handle_category_clarification(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Lida com a resposta do usu√°rio √† clarifica√ß√£o da categoria."""
    supabase_client = context.bot_data['supabase_client']
    user_response = update.message.text
    pending_transaction = context.user_data.get('pending_transaction')

    if not pending_transaction:
        await update.message.reply_text("Ops! üò¨ N√£o encontrei uma transa√ß√£o pendente. Por favor, tente registrar seu gasto novamente. üîÑ", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END

    valor = pending_transaction['valor']
    data = pending_transaction['data']
    original_category_text = pending_transaction['original_category_text']
    suggestions = pending_transaction['suggestions']
    forma_pagamento_text = pending_transaction['forma_pagamento_text']
    descricao_gasto = pending_transaction['descricao_gasto']

    chosen_category_id = None
    chosen_category_name = None

    user_response_camel_case = to_camel_case(user_response)

    for suggestion in suggestions:
        if user_response_camel_case == suggestion['nome']:
            chosen_category_id = suggestion['id']
            chosen_category_name = suggestion['nome']
            break
    
    if not chosen_category_id:
        all_categorias = db.get_categorias(supabase_client)
        for cat in all_categorias:
            if user_response_camel_case == cat['nome']:
                chosen_category_id = cat['id']
                chosen_category_name = cat['nome']
                break

    if chosen_category_id:
        context.user_data['pending_transaction']['categoria_id'] = chosen_category_id
        context.user_data['pending_transaction']['categoria_nome_db'] = chosen_category_name
        
        # Categoria resolvida. Agora verifica a forma de pagamento.
        forma_pagamento_id = None
        forma_pagamento_nome_real = None
        if forma_pagamento_text:
            forma_pagamento_normalizada = to_camel_case(forma_pagamento_text)
            formas_pagamento_db_info = db.get_formas_pagamento(supabase_client)
            for fp in formas_pagamento_db_info:
                if fp['nome'] == forma_pagamento_normalizada:
                    forma_pagamento_id = fp['id']
                    forma_pagamento_nome_real = fp['nome']
                    break
        
        if not forma_pagamento_id:
            formas_pagamento_disponiveis = db.get_formas_pagamento(supabase_client)
            keyboard_options = [[fp['nome']] for fp in formas_pagamento_disponiveis]
            keyboard_options.append(["Outro / N√£o sei ‚ùì"])
            reply_markup = ReplyKeyboardMarkup(keyboard_options, one_time_keyboard=True, resize_keyboard=True)
            await update.message.reply_text(
                "üí≥ Qual foi a forma de pagamento?",
                reply_markup=reply_markup
            )
            return ASKING_PAYMENT_METHOD
        else:
            # Se tudo foi resolvido, vai para a confirma√ß√£o
            context.user_data['pending_transaction']['forma_pagamento_id'] = forma_pagamento_id
            context.user_data['pending_transaction']['forma_pagamento_nome_real'] = forma_pagamento_nome_real
            await _send_confirmation_message(update, context, context.user_data['pending_transaction'])
            return ASKING_CONFIRMATION

    elif user_response.lower() == "criar nova categoria ‚ûï":
        await update.message.reply_text("üìù Ok, qual o nome da nova categoria para este gasto?", reply_markup=ReplyKeyboardRemove())
        return ASKING_NEW_CATEGORY_NAME

    elif user_response.lower() == "n√£o se aplica / outra ü§∑‚Äç‚ôÄÔ∏è":
        await update.message.reply_text("‚úçÔ∏è Entendi. Por favor, digite o nome da categoria correta para este gasto.", reply_markup=ReplyKeyboardRemove())
        return ASKING_NEW_CATEGORY_NAME

    else:
        await update.message.reply_text(
            f"ü§î N√£o entendi sua resposta. Por favor, digite o nome exato de uma das sugest√µes, "
            f"ou 'Criar nova categoria ‚ûï' ou 'N√£o se aplica / Outra ü§∑‚Äç‚ôÄÔ∏è'.",
            reply_markup=ReplyKeyboardRemove()
        )
        return ASKING_CATEGORY_CLARIFICATION


async def handle_new_category_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Lida com o nome da nova categoria fornecido pelo usu√°rio."""
    supabase_client = context.bot_data['supabase_client']
    new_category_name_input = update.message.text
    pending_transaction = context.user_data.get('pending_transaction')

    if not pending_transaction:
        await update.message.reply_text("Ops! üò¨ N√£o encontrei uma transa√ß√£o pendente. Por favor, tente registrar seu gasto novamente. üîÑ", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END

    valor = pending_transaction['valor']
    data = pending_transaction['data']
    original_category_text = pending_transaction['original_category_text']
    forma_pagamento_text = pending_transaction['forma_pagamento_text']
    descricao_gasto = pending_transaction['descricao_gasto']

    if db.add_categoria(supabase_client, new_category_name_input, limite_mensal=None):
        new_category_name_camel_case = to_camel_case(new_category_name_input)
        categoria_id = db.get_categoria_id_by_text(supabase_client, new_category_name_camel_case)
        
        if categoria_id:
            context.user_data['pending_transaction']['categoria_id'] = categoria_id
            context.user_data['pending_transaction']['categoria_nome_db'] = new_category_name_camel_case
            
            forma_pagamento_id = None
            forma_pagamento_nome_real = None
            if forma_pagamento_text:
                forma_pagamento_normalizada = to_camel_case(forma_pagamento_text)
                formas_pagamento_db_info = db.get_formas_pagamento(supabase_client)
                for fp in formas_pagamento_db_info:
                    if fp['nome'] == forma_pagamento_normalizada:
                        forma_pagamento_id = fp['id']
                        forma_pagamento_nome_real = fp['nome']
                        break

            if not forma_pagamento_id:
                formas_pagamento_disponiveis = db.get_formas_pagamento(supabase_client)
                keyboard_options = [[fp['nome']] for fp in formas_pagamento_disponiveis]
                keyboard_options.append(["Outro / N√£o sei ‚ùì"])
                reply_markup = ReplyKeyboardMarkup(keyboard_options, one_time_keyboard=True, resize_keyboard=True)
                await update.message.reply_text(
                    "üí≥ Qual foi a forma de pagamento?",
                    reply_markup=reply_markup
                )
                return ASKING_PAYMENT_METHOD
            else:
                # Tudo resolvido, vai para a confirma√ß√£o
                context.user_data['pending_transaction']['forma_pagamento_id'] = forma_pagamento_id
                context.user_data['pending_transaction']['forma_pagamento_nome_real'] = forma_pagamento_nome_real
                await _send_confirmation_message(update, context, context.user_data['pending_transaction'])
                return ASKING_CONFIRMATION

        else:
            nome_existente_camel_case = to_camel_case(new_category_name_input)
            await update.message.reply_text(f"‚ö†Ô∏è N√£o foi poss√≠vel criar a categoria '{nome_existente_camel_case}'. Ela j√° existe ou houve um erro. Por favor, tente novamente ou escolha uma categoria existente. üßê", reply_markup=ReplyKeyboardRemove())
            return ConversationHandler.END
    
async def handle_payment_method(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Lida com a forma de pagamento fornecida pelo usu√°rio."""
    supabase_client = context.bot_data['supabase_client']
    user_response_payment = update.message.text
    pending_transaction = context.user_data.get('pending_transaction')

    if not pending_transaction:
        await update.message.reply_text("Ops! üò¨ N√£o encontrei uma transa√ß√£o pendente. Por favor, tente registrar seu gasto novamente. üîÑ", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END
    
    valor = pending_transaction['valor']
    data = pending_transaction['data']
    categoria_id = pending_transaction['categoria_id']
    categoria_nome_db = pending_transaction['categoria_nome_db']
    original_category_text = pending_transaction['original_category_text']
    descricao_gasto = pending_transaction['descricao_gasto']

    final_payment_method_name = to_camel_case(user_response_payment)
    forma_pagamento_id = db.get_forma_pagamento_id_by_name(supabase_client, final_payment_method_name)

    if not forma_pagamento_id:
        if user_response_payment.lower() not in ["outro / n√£o sei ‚ùì", "outro", "n√£o sei", "nao sei"]:
            try:
                response_add_fp = supabase_client.table('formas_pagamento').insert({'nome': final_payment_method_name}).execute()
                if response_add_fp.data:
                    # Supabase `insert` retorna uma lista de dicion√°rios, pegue o ID do primeiro elemento
                    forma_pagamento_id = response_add_fp.data[0]['id'] 
                    await update.message.reply_text(f"‚ú® Forma de pagamento '{final_payment_method_name}' adicionada para uso futuro! üí≥", reply_markup=ReplyKeyboardRemove())
                else:
                    await update.message.reply_text(f"‚ö†Ô∏è N√£o foi poss√≠vel adicionar a forma de pagamento '{final_payment_method_name}'. Usando 'N√£o Informado'. üòï", reply_markup=ReplyKeyboardRemove())
            except Exception as e:
                print(f"Erro ao adicionar nova forma de pagamento: {e}")
                await update.message.reply_text(f"‚ö†Ô∏è Erro ao adicionar nova forma de pagamento. Usando 'N√£o Informado'. üòï", reply_markup=ReplyKeyboardRemove())
        
        if not forma_pagamento_id:
            forma_pagamento_id = db.get_forma_pagamento_id_by_name(supabase_client, 'NaoInformado')
            final_payment_method_name = 'N√£o Informado' if forma_pagamento_id else 'Desconhecido'
            if not forma_pagamento_id:
                await update.message.reply_text("üö® Aten√ß√£o: A forma de pagamento 'N√£o Informado' n√£o existe. Gasto registrado sem forma de pagamento. ‚ö†Ô∏è", reply_markup=ReplyKeyboardRemove())

    context.user_data['pending_transaction']['forma_pagamento_id'] = forma_pagamento_id
    context.user_data['pending_transaction']['forma_pagamento_nome_real'] = final_payment_method_name
    
    await _send_confirmation_message(update, context, context.user_data['pending_transaction'])
    return ASKING_CONFIRMATION


async def handle_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Lida com a confirma√ß√£o (Sim/N√£o) da transa√ß√£o."""
    user_response = update.message.text.lower()
    pending_transaction = context.user_data.get('pending_transaction')

    if not pending_transaction:
        await update.message.reply_text("Ops! üò¨ N√£o encontrei uma transa√ß√£o pendente para confirmar. üîÑ", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END

    if user_response == 'sim ‚úÖ' or user_response == 'sim':
        if pending_transaction['transaction_type'] == 'gasto':
            await _register_gasto(update, context, pending_transaction)
        elif pending_transaction['transaction_type'] == 'ganho':
            await _register_ganho(update, context, pending_transaction)
        
        context.user_data.pop('pending_transaction', None) # Limpa a transa√ß√£o pendente
        return ConversationHandler.END # Fim da conversa

    elif user_response == 'n√£o ‚ùå' or user_response == 'n√£o' or user_response == 'nao':
        await update.message.reply_text(
            "Entendido! ü§î O que precisa ser alterado? \n"
            "Por favor, digite o campo e o novo valor. \n"
            "Exemplos: 'Categoria Lazer üõçÔ∏è', 'Valor 60.50 üí∞', 'Data 2025-07-01 üìÖ', 'Forma Pix üí≥', 'Descricao Jantar de Anivers√°rio üéÇ'.",
            reply_markup=ReplyKeyboardRemove()
        )
        return ASKING_CORRECTION # Entra no estado de corre√ß√£o

    else:
        keyboard = [["Sim ‚úÖ", "N√£o ‚ùå"]]
        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
        await update.message.reply_text(
            "Por favor, responda apenas 'Sim ‚úÖ' ou 'N√£o ‚ùå'.",
            reply_markup=reply_markup
        )
        return ASKING_CONFIRMATION # Permanece no estado de confirma√ß√£o


async def handle_correction(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Lida com a corre√ß√£o de um campo da transa√ß√£o."""
    supabase_client = context.bot_data['supabase_client']
    correction_text = update.message.text
    pending_transaction = context.user_data.get('pending_transaction')

    if not pending_transaction:
        await update.message.reply_text("Ops! üò¨ N√£o encontrei uma transa√ß√£o pendente para corrigir. üîÑ", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END

    # Extrai o campo e o novo valor da corre√ß√£o usando o Llama
    correction_parsed = extract_correction_from_llama(correction_text) # <-- CORRE√á√ÉO AQUI

    if not correction_parsed:
        await update.message.reply_text(
            "N√£o consegui entender a corre√ß√£o. üòï Por favor, tente novamente no formato 'Campo Valor'. \n"
            "Exemplos: 'Categoria Lazer üõçÔ∏è', 'Valor 60.50 üí∞', 'Data 2025-07-01 üìÖ', 'Forma Pix üí≥', 'Descricao Jantar üçΩÔ∏è'.",
            reply_markup=ReplyKeyboardRemove() # Remove keyboard se n√£o entendeu
        )
        return ASKING_CORRECTION

    campo = correction_parsed.get('campo')
    novo_valor = correction_parsed.get('novo_valor')

    if not campo or novo_valor is None:
        await update.message.reply_text(
            "N√£o consegui identificar o campo e o novo valor da corre√ß√£o. ü§î \n"
            "Exemplos: 'Categoria Lazer üõçÔ∏è', 'Valor 60.50 üí∞'.",
            reply_markup=ReplyKeyboardRemove()
        )
        return ASKING_CORRECTION

    # Aplica a corre√ß√£o na transa√ß√£o pendente
    if campo.lower() == 'valor':
        try:
            pending_transaction['valor'] = float(str(novo_valor).replace(',', '.'))
            await update.message.reply_text("Valor atualizado! üí∞")
        except ValueError:
            await update.message.reply_text("Valor inv√°lido para o campo 'Valor'. Tente novamente. üî¢")
            return ASKING_CORRECTION
    elif campo.lower() == 'data':
        try:
            # Valida o formato e atualiza o pending_transaction
            datetime.datetime.strptime(str(novo_valor), '%Y-%m-%d')
            pending_transaction['data'] = str(novo_valor)
            await update.message.reply_text("Data atualizada! üìÖ")
        except ValueError:
            await update.message.reply_text("Formato de data inv√°lido. Use AAAA-MM-DD. Tente novamente. üóìÔ∏è")
            return ASKING_CORRECTION
    elif campo.lower() == 'categoria':
        nova_categoria_id = db.get_categoria_id_by_text(supabase_client, str(novo_valor))
        if nova_categoria_id:
            pending_transaction['categoria_id'] = nova_categoria_id
            pending_transaction['categoria_nome_db'] = to_camel_case(str(novo_valor))
            await update.message.reply_text("Categoria atualizada! üè∑Ô∏è")
        else:
            keyboard = [["Sim ‚úÖ", "N√£o ‚ùå"]]
            reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
            context.user_data['pending_transaction_temp_category_name'] = str(novo_valor)
            await update.message.reply_text(f"Categoria '{str(novo_valor)}' n√£o encontrada. Deseja cri√°-la? ‚ûï", reply_markup=reply_markup)
            context.user_data['correction_state'] = 'ASKING_CREATE_NEW_CATEGORY' # Estado tempor√°rio para lidar com a sub-resposta
            return ASKING_CORRECTION
    elif campo.lower() == 'forma' or campo.lower() == 'forma_pagamento':
        nova_forma_id = db.get_forma_pagamento_id_by_name(supabase_client, str(novo_valor))
        if nova_forma_id:
            pending_transaction['forma_pagamento_id'] = nova_forma_id
            pending_transaction['forma_pagamento_nome_real'] = to_camel_case(str(novo_valor))
            await update.message.reply_text("Forma de pagamento atualizada! üí≥")
        else:
            await update.message.reply_text(f"Forma de pagamento '{str(novo_valor)}' n√£o encontrada. Verifique `/categorias` ou tente outra. ü§∑‚Äç‚ôÄÔ∏è", reply_markup=ReplyKeyboardRemove())
            return ASKING_CORRECTION
    elif campo.lower() == 'descricao' or campo.lower() == 'descricao_gasto':
        pending_transaction['descricao_gasto'] = str(novo_valor)
        await update.message.reply_text("Descri√ß√£o atualizada! üìù")
    elif campo.lower() == 'tipo':
        if novo_valor.lower() in ['gasto', 'ganho']:
            pending_transaction['transaction_type'] = novo_valor.lower()
            # Ajusta campos espec√≠ficos se mudar de tipo
            if novo_valor.lower() == 'gasto':
                pending_transaction.pop('descricao', None) # Remove 'descricao' de ganho
                if 'categoria_id' not in pending_transaction: pending_transaction['categoria_id'] = None
                pending_transaction['descricao_gasto'] = pending_transaction.get('descricao_gasto') or "" # Garante que tem a chave para gasto
            else: # ganho
                pending_transaction.pop('categoria_id', None)
                pending_transaction.pop('forma_pagamento_id', None)
                pending_transaction.pop('descricao_gasto', None)
                if 'descricao' not in pending_transaction: pending_transaction['descricao'] = None # Garante que tem a chave para ganho
            await update.message.reply_text(f"Tipo de transa√ß√£o alterado para '{novo_valor.lower()}'! üîÑ")
        else:
            await update.message.reply_text("Tipo de transa√ß√£o inv√°lido. Use 'gasto' ou 'ganho'. Tente novamente. üßê")
            return ASKING_CORRECTION
    else:
        await update.message.reply_text(f"Campo '{campo}' n√£o reconhecido para corre√ß√£o. Tente novamente com um campo v√°lido. ü§∑‚Äç‚ôÄÔ∏è", reply_markup=ReplyKeyboardRemove())
        return ASKING_CORRECTION

    # L√≥gica para criar nova categoria a partir da corre√ß√£o se ASK_CREATE_NEW_CATEGORY
    if context.user_data.get('correction_state') == 'ASKING_CREATE_NEW_CATEGORY':
        user_response_sub = update.message.text.lower()
        if user_response_sub == 'sim ‚úÖ' or user_response_sub == 'sim':
            new_category_name_from_correction = context.user_data.get('pending_transaction_temp_category_name')
            if new_category_name_from_correction:
                if db.add_categoria(supabase_client, new_category_name_from_correction, limite_mensal=None):
                    new_category_camel_case = to_camel_case(new_category_name_from_correction)
                    new_cat_id = db.get_categoria_id_by_text(supabase_client, new_category_camel_case)
                    if new_cat_id:
                        pending_transaction['categoria_id'] = new_cat_id
                        pending_transaction['categoria_nome_db'] = new_category_camel_case
                        await update.message.reply_text(f"üéâ Categoria '{new_category_camel_case}' criada e aplicada! ‚ú®", reply_markup=ReplyKeyboardRemove())
                    else:
                        await update.message.reply_text("‚ö†Ô∏è Erro ao aplicar nova categoria. Tente novamente. üòï", reply_markup=ReplyKeyboardRemove())
                else:
                    await update.message.reply_text("‚ö†Ô∏è Erro ao criar nova categoria. Tente novamente. üòï", reply_markup=ReplyKeyboardRemove())
            else:
                await update.message.reply_text("‚ö†Ô∏è Erro: Nome da nova categoria n√£o encontrado. Tente corrigir novamente. üßê", reply_markup=ReplyKeyboardRemove())
        else: # user_response.lower() == 'n√£o' ou outra coisa
            await update.message.reply_text("üö´ Ok, a cria√ß√£o da categoria foi cancelada. Por favor, corrija a categoria para uma existente ou crie-a manualmente depois. üìù", reply_markup=ReplyKeyboardRemove())
        
        context.user_data.pop('correction_state', None)
        context.user_data.pop('pending_transaction_temp_category_name', None)


    # Se a corre√ß√£o foi aplicada (e n√£o estamos em um sub-estado de cria√ß√£o de categoria), mostra a transa√ß√£o novamente para confirma√ß√£o
    if context.user_data.get('correction_state') != 'ASKING_CREATE_NEW_CATEGORY':
        await _send_confirmation_message(update, context, pending_transaction)
    
    return ASKING_CONFIRMATION # Retorna para o estado de confirma√ß√£o ap√≥s a corre√ß√£o